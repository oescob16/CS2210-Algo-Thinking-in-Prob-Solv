The Problem:
  Given two strings s1, s2, find the lowest ASCII sum of deleted characters to make two strings equal.
  
1. Define the problem/solution recursively

- Given s1 and s2 we have to find the minimum ASCII sum of characters needed to make these two strings equal.
- This problem uses the same idea as the edit_distance problem, only that instead of computing the minimum operations (replace, delete, insert)
  to convert s1 to s2 we have to delete chars from both strings to make s1==s2.
- If s1[i] != s2[i], then we are going to see which one has the less cost to delete + prev computations. 
- If s1[i] == s2[i], then we are not going to delete anything, instead we will grab the prev ascii sum.

Edge/Base Cases:
- If s1 is the empty string and s2 is a non-empty string, then we will have to delete all the characters in s2 and acumulate the sum.
- The same if s2 is empty.

- For example:
  
  Input: s1 = "sea", s2 = "eat"
  Output: 231
  Here we are deleting 's' from s1 and t from s2. Why? Because if we delete those we will make s1==s2 and with a minimum cost. 

- To get to the output in a recursive way we have to compare all chars from s1 to ach char in s2 by slicing, and likewise with s2, 
  then we would grab the minimum of those computations
  
- So,
    sea -> ea -> e -> ''
                 a -> ''
        -> se -> s ->
                 e -> ''
        -> sa -> a -> ''
                 s -> ''
    eat -> eat -> eat -> eat (same with s2)
    
    Compare s1[i] with all s2[i] and s2[i] with all s1[i], get cumulative sum and backtrack.
    There are so many repeated computations.

2. Briefly talk about how you plan to store solutions to sub-problems and combining them to solve the global problem

- Translating this problem to a dp table (similar to edit_distance) will look like this:

    ''    s    e    a
'' [ 0,   115, 216, 313] Here we first have to cover the edge case when s1 or s2 are empty.
 e [ 101, 0,   0,   0] To make s1='' and s2='sea' be the same, we have to delete all characters from s2. And, therefore make the cumulative sum of the ascii value.
 a [ 198, 0,   0,   0] For instance, to delete 'sea' we have to delete all its characters and accumulate the ascii sum, so ord(s)=115 + ord(e)=216 + ord(a)=313.
 t [ 314, 0,   0,   0] The same applies when s2 is empty and s1 is non-empty.
  
- Since we already fill the first row and first column we will start iterating at second row and second column.
- Whenever we see that s1[i] matches s2[i] (char1==char2) we will grab the value from the nearest top left corner, that is, dp[i-1][j-1], and assign it to dp[i][j].
- When char1 and char2 mismatch, then we will grab the left cumulative sum (s1) + s2[i] and the top cumulative sum (s2) + s1[i], 
  and check which character (char1 and char2) has the less cost to delete and then add it to dp[i][j].
- In short, at dp[i][j] we will store the sub-problems of the substring[i:j] we have right now.
- For example, say we have the sub-problem dp[1][1] s1='e' and s2='s', then we have to grab the computation of deleting 's' and 'e' and add it together.
    
   
  
  
  
